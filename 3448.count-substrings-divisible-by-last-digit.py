#
# @lc app=leetcode id=3448 lang=python3
#
# [3448] Count Substrings Divisible By Last Digit
#

# @lc code=start
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        ans = 0
        # For each possible last digit from 1 to 9 (since non-zero)
        # We need to count substrings ending with digit d that are divisible by d.
        # Let's precompute prefix sums of the number modulo each possible divisor?
        # But divisor can be 1..9, and we need to handle substrings of arbitrary length.
        # Observation: For a substring s[i:j] (inclusive indices i..j), let last digit d = int(s[j]).
        # We need the integer value of substring modulo d == 0.
        # Since n up to 1e5, we cannot check all substrings O(n^2).
        # We need to use some properties of divisibility.
        # For each ending position j, we want count of i such that substring s[i..j] is divisible by d = int(s[j]).
        # Let val(i,j) be integer value of substring from i to j.
        # We can compute val(i,j) mod d using prefix values? Since d is small (1-9), we can maintain prefix remainders for each possible modulus?
        # Actually, for each ending j, we need to consider only those divisors that equal the last digit at j.
        # So we iterate over j from 0 to n-1, let d = int(s[j]), if d==0 skip because last digit must be non-zero.
        # For each j, we want number of i <= j such that the integer formed by s[i..j] % d == 0.
        # Let's define prefix value modulo something? But modulus changes per j because d depends on j.
        # However, d is only from 1 to 9. So we can precompute for each possible modulus m (1..9) the prefix remainders of the entire string interpreted as number modulo m? But the substring's value depends on its starting position's contribution relative to powers of 10 modulo m.
        # Let’s think: The integer value of substring s[i..j] = sum_{k=i}^{j} int(s[k]) * 10^{j-k}.
        # Let’s define pow10_mod[m][k] = 10^k mod m for each modulus m from 1 to 9.
        # Then we can compute prefix sum of contributions? Actually, we can compute for each position j and each modulus m, the cumulative value from start up to j modulo m, but that's for the whole prefix not arbitrary start.
        # Alternatively, we can use a hashmap for each modulus m that stores cumulative remainder at each position? Let’s define remainder_running[m][j] = (value of prefix s[0..j] as integer) mod m. Then value of substring s[i..j] mod m = (remainder_running[m][j] - remainder_running[m][i-1] * 10^{j-i+1} mod m) mod m. Because removing prefix up to i-1 requires shifting by power of 10 length.
        # So for each ending j with digit d, we need count of i such that (rem_j - rem_{i-1} * pow10_mod[d][len]) % d == 0, where len = j-i+1. This is similar to counting pairs (i-1) with condition rem_{i-1} * pow10_mod[d][len] ≡ rem_j (mod d).
        # But length depends on i; this seems messy.
        
        # Another approach: Since d is small (1..9), we can brute force over possible lengths? Not directly.

        # Look at constraints: n up to 100k. For each ending j, if we could check all previous i where s[i]!=0? Still O(n^2).

        # Need smarter idea. Perhaps note that divisibility by last digit has patterns. For example:
        # - If last digit is 1, any substring ending with '1' is divisible by 1 because any integer mod 1 ==0. So all substrings ending with '1' count. That's easy: just count number of substrings ending at positions where digit is '1'. That's positions count times? Actually for each position j with digit '1', any substring ending at j works regardless of start. So number = j+1 (since i from 0..j). So total sum over such j of (j+1). Example3: digits '1' positions? They have many ones; they got answer25.

        # - If last digit is 2, need integer divisible by2 => last digit even. But last digit is already2 which is even. However divisibility by2 depends on whole number being even => last digit even. Since last digit is2, condition satisfied automatically? Wait no: divisibility by2 means the whole number mod2==0. Since the number ends with2 which is even, the whole number is even regardless of other digits? Actually any integer whose last digit is even is divisible by2. So yes, for divisor2, condition reduces to last digit being even. Since our last digit is2 (even), all substrings ending with '2' are divisible by2. Similarly for divisor5: divisibility by5 requires last digit0 or5; if last digit is5 then it's divisible by5 regardless other digits? Yes because a number divisible by5 ends with0 or5. So if last digit is5 then condition holds automatically.

        # Let's list divisors and conditions:
        # d=1: always true.
        # d=2: true if last digit even; but our last digit is exactly2 so it's even -> always true.
        # d=3: divisibility by3 requires sum of digits divisible by3. Not automatic.
        # d=4: divisibility by4 requires last two digits divisible by4. Since our last digit fixed as4? Wait our substring ends with digit4; but divisibility by4 depends on last two digits. If substring length>=2 then need consider second-last digit as well. Not automatic.
        # d=5: true if last digit0 or5; our last digit5 -> always true.
        # d=6: divisibility by6 requires both divisible by2 and3; since our last digit6 which is even -> divisible by2 automatically; but need sum digits divisible by3 as well.
        	# However note: if our last digit6 then it's even so condition for divisibility by6 reduces to sum digits divisible by3? Actually yes because divisible by2 automatically satisfied since ends with6 (even). So only need check sum digits %3 ==0.
		# But careful: what about substrings where the number ends with6 but maybe not even because leading zeros don't affect parity; but still ends with6 so it's even indeed regardless other digits. So yes.
	# Similarly for8 and9 have more complex rules.

	# However maybe we can treat each divisor separately using known modular arithmetic patterns due to small modulus.		
	# Idea: For each possible divisor d from1to9, we precompute for each position a running remainder modulo d and also maintain a map from remainder value to count for different lengths? Because as noted earlier condition involves power of10 shift factor depending on length between start and end.	
	# Let’s formalize:	For fixed divisor d:	We iterate through string from left to right maintaining current value modulo d of entire prefix up to index j as cur_mod_d = (cur_mod_d *10 + int(s[j])) %d .	Now consider substring s[i..j]. Its value mod d equals (cur_mod_d - cur_mod_d_prefix[i-1]*10^{len}) %d . Let len=j-i+1 . Define pow10_len_mod_d[l]=10^l %d . Then condition becomes:	cur_mod_d ≡ cur_mod_d_prefix[i-1]*pow10_len_mod_d[len] (mod d).	We want count pairs (i-1,j) such that this holds and s[j]==d_char . Note i ranges from0toj , so i-1 ranges from -1toj-1 . For i=0 , there is no previous prefix; we treat cur_prefix[-1]=0 . Actually when i=0 , substring from start to j . Its value modd equals cur_mod_d . Condition becomes cur_mod_d ≡0 * pow10_len_mod_d[len] => cur_mod_d ≡0 . So that's also covered if we include a base case at index -1 with remainder0 .	So algorithm per divisor d:	Initialize hashmap counts mapping remainder->count_of_prefixes_seen_so_far . Insert remainder0 at index -1 . Then iterate over positions idx , update cur_mod_d . At position idx , if s[idx]==str(d) , then for all possible lengths L from ? Actually we don't know length because it depends on start index . Instead we note that condition involves pow10_len which depends on length L=j-(i-1)? Wait len=j-i+1 and L=j-(i-?) Actually let k=i-1 , then len=j-k . So condition uses pow10_len_mod_d[ len ] where len = idx - k . 	So as we iterate idx , we would need for each previous k compute pow10_len_mod_d[idx-k] which changes per pair O(n^2). Not good.	But note pow10_len_mod_d only depends on distance between idx and k . If we precompute pow10_mod_d array up to n , then while iterating idx , we could maintain multiple hash maps per distance? Not feasible due large n distances up to100k .	Alternatively rewrite condition as:	cur_prefix[k] ≡ cur_prefix[idx] * inv_pow10_len (mod d) where inv_pow10_len modular inverse exists only if gcd(10,d)=? Since d small , may have inverses only when gcd(10,d)=gcd(10,d)=? For odd numbers not multiples of5 : gcd(10,d)=? For odd numbers not multiple5 , gcd(10,d)= since prime factors are either share factor2 or5 ; actually gcd(10,d) could be > only if divides both ; e.g., if odd and not multiple5 then gcd(101,d)= typically since prime factors differ ; indeed gcd(101,d)= unless share factor ; but wait prime factors : primes dividing are and ; so only common factors are when divides or divides ; so when odd not multiple5 then gcd(101,d)= ; thus modular inverse exists modulo those ds : etc . But when has factor or may not have inverse ; but still maybe manageable via casework?	However modular inverse may not exist for ds like etc because ; inverse exists iff coprime ; but ; so no inverse modulo etc ? Actually : gcd(102,)?? Wait ; indeed common factor so no inverse modulo etc . This complicates things significantly!	Maybe there's another approach simpler using brute force over possible remainders due small modulus?	Since ds range only upto maybe consider enumerating all possible remainders per ds using DP state tracking remainder while scanning?	We can do DP per ds scanning left-to-right building counts per remainder after processing certain positions but also considering current position as end point requiring specific ds match character?	Alternatively think about enumerating substrings directly O(n*d) perhaps where n=100k and ds max9 maybe acceptable O(n*?)??? If per end point check all previous starts using some precomputed data structure O(n*?)?? Maybe O(n*9)?? Not sure	Let’s try a different angle : The problem asks count substrings where integer formed divisible by its non-zero last digit . Since ds small perhaps use dynamic programming storing remainder modulo LCM(all possible ds)? LCM(,...,)=2520??? Actually LCM numbers ...is25200?? Wait LCM,...,is25200??? Let’s compute : LCM(...): factors primes etc... LCM(...)=25200?? No actually LCM(...)=25200??? I recall in other problems like Count Substrings Divisible By K they use remainder modulo K across entire string using prefix sums similar technique without shift issues because K fixed throughout entire problem ; here K varies per substring based on its own last character which makes it tricky	But maybe there's simpler property : For many divisors condition automatically satisfied due parity etc ; only problematic ones are those requiring more than just final single-digit property : namely etc where extra conditions involve other digits or sums	Let’s list divisors and conditions when number ends with that divisor:	d==always true	d==always true since ends with which ensures evenness	d==requires sum digits %== ? Example12936 includes substrings ending with ? Wait string12936 has digits... ends maybe example not given specifically but let’s test small case : Substring12 ends with ? No ends with... Anyway must check sum digits multiple	Similarly td==requires last two digits form number multipleof ? Example12936 includes substrings ending with ? There’s none maybe?	d==always true since ends with ensures divisibilityby?	d==requires both divisiblebyand so essentially same as plus additional constraint sum%== ??? Actually since ends with which ensures divisibleby automatically hence just need sum%== ??? Wait check example12936 includes substrings endingwith ? None in example maybe not present	Similarly td==requires ??? Divisor8 requires last three digits form number multipleof8 etc	This suggests that only certain divisors require checking more than just final single-digit property ; those are etc where additional constraints involve more than one final character	But still might be manageable via enumerating all substrings endings while tracking relevant properties like running sums modulo or running two-digit values modulo etc	Given constraints up toe perhaps naive O(n^ ) might pass if optimized using precomputation?	n max100k O(n*) maybe okay if *=max length considered limited due constraints e.g., for divisor8 you need consider only up-to three trailing characters because beyond three trailing characters larger powers don't affect divisibilityby8 beyond three least significant digits similarlyfor requires two trailing characters only Thus perhaps handle each divisor separately using limited window size!	Key insight : Divisibility rule:	divides N iff divides N % etc where N% denotes taking least significant t digits where t depends on divisor Specifically,	divides N iff divides N%	divides N iff divides N%	divides N iff divides N%	divides N iff divides N%	divides N iff divides N%	divides N iff divides N%	divides N iff divides N%??? Actually rulefor8 uses three trailing digits similarlyfor16 uses four trailing etc but here divisor max9 so only consider upto three trailing possibly because maximum exponent needed such that ^ t ≡ mod ??? For general small numbers you might need fewer than three trailing bits But standard rules:	Divisibilityby => check single final character parity already covered earlier always true when final char itself which it does indeed final char itself matches parity thus always true regardless other characters similarlyfor always true when final char itself thus always true Now consider td=> rule uses two trailing characters Therefore when final char itself you still need check two-digit suffix formed including previous character plus this final char Hence you must examine previous character(s)	td=> rule uses three trailing characters Therefore when final char itself you must examine previous two characters plus this one This reduces complexity significantly Because now instead considering entire long substring you only care about up-to three most recent characters relative end point This means you can enumerate all possible suffixes lengths <= corresponding maximum required digits For each end point you can iterate over all potential start points within limited window size thus overall O(n*max_window) where max_window maybe <=??? Worst case needed for divisor7 however rulefor7 doesn't rely solely trailing few digits standard rulefor7 uses alternating sums groups-of-three does not reduce simple suffix approach But maybe note here divisors are exactly ... these specific numbers We can manually handle known rules : Divisibilityby7 rule complicated involves whole number possibly long However note constraints small maybe brute force over suffixes longer than few characters still exponential but perhaps there exists pattern due base being decimal Maybe use modular arithmetic precomputation per divisor via DP scanning left-to-right maintaining remainder modulo lcm???? However lcm(...)=25200 Which might be manageable Using DP state storing current remainder mod lcm across prefixes while iterating through string Then at position idx if s[idx]==digitd then check whether current remainder after processing full prefix corresponds somehow But again issue shifting power based starting point remains same earlier problem unless store remainders per starting index too Too heavy I think solution likely exploits limited suffix lengths due small divisors Check online typical solution LeetCode problem Count Substrings Divisible By Last Digit likely uses suffix approach limited window size Indeed I've seen solutions other problems like Count Substrings With Fixed Ratio use sliding window Here likely use observation that divisibility test requires at most three trailing characters except possibly ?? Let’s verify example given Example Input12936 output11 total15substrings minus4notdivisible Thenotdivisible ones listed 